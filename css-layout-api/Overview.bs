<pre class='metadata'>
Title:  CSS Layout API Level 1
Status: DREAM
Group: houdini
ED: https://drafts.css-houdini.org/css-layout-api-1/
Shortname: css-layout-api
Level: 1
Abstract:
Editor: Greg Whitworth, gwhit@microsoft.com 
Editor: Ian Kilpatrick, ikilpatrick@chromium.org
Editor: Tab Atkins, jackalmage@gmail.com
Editor: Shane Stephens, shanestephens@google.com
Editor: Robert O'Callahan, robert@ocallahan.org
Editor: Rossen Atanassov, rossen.atanassov@microsoft.com
</pre>

<pre class="link-defaults">
spec:css-break-3; type:dfn; text:fragment
spec:css-display-3; type:dfn; text:box
spec:css-display-3; type:value; for:display; text:none
spec:dom; type:dfn; text:element
</pre>

Introduction {#intro}
=====================

The layout stage of CSS is responsible for generating and positioning <a>fragments</a> from a tree
of <a>boxes</a>.

This specification describes an API which allows developers to layout a <a>box</a> in response to
computed style and <a>box</a> tree changes.

Layout Model and Terminology {#layout-model-and-terminology}
============================================================

The <dfn>current layout</dfn> is the layout algorithm for the {{Box}} we are currently performing
layout for.

The <dfn>parent layout</dfn> is the layout algorithm for the {{Box}}'s direct parent, (the layout
algorithm which is requesting the <a>current layout</a> to be performed).

A <dfn>child layout</dfn> is the layout algorithm for a child {{Box}} of the <a>current layout</a>.

Layout Boxes {#layout-boxes}
----------------------------

<pre class='idl'>
interface Box {
    readonly attribute StylePropertyMapReadOnly styleMap;
    FragmentRequestToken doLayout(DerivedConstraintSpace space, ChildBreakToken breakToken);
};
</pre>

A {{Box}} represents a CSS generated <a>box</a> before any layout has occurred. (The box will have a
computed value of 'display' that is not ''none''). The {{Box}} does not contain any layout
information itself (like inline or block size) but can be used to generate {{Fragment}}s which do
contain layout information.

An author cannot construct a {{Box}} with this API, this happens at a separate stage of the
rendering engine (post style resolution).

A box could be generated by:

 - An <a>element</a>.

 - A <a>::before</a> or <a>::after</a> pseudo-element.

    NOTE: Other pseudo-elements such as <a>::first-letter</a> or <a>::first-line</a> do not generate
        a box for layout purposes. They are additional styling information for a text node.

 - A <a>Text</a> node.

 - An anonymous box. For example an anonymous box may be inserted as a result of:

    - A <a>Text</a> node which has undergone <a>blockification</a>.

    - An element with ''display: table-cell'' which doesn't have a parent with ''display: table''.

An array of {{Box}}es is passed into the <a>layout method</a> which represents the child boxes of
the current box which is being laid out.

The author can query the <a>computed style</a> of the child box through the {{Box/styleMap}}
attribute. The {{Box/styleMap}} will only contain properties which are listed in the <a>child input
properties</a> array.

To perform layout on a box the author can invoke the {{Box/doLayout()}} method. This will produce a
{{Fragment}} which contains layout information.

The {{Box/doLayout()}} method may be invoked multiple times with different arguments to query the
{{Box}} for different layout information.

Layout Fragments {#layout-fragments}
------------------------------------

<pre class='idl'>
interface Fragment {
    readonly attribute double inlineSize;
    readonly attribute double blockSize;

    readonly attribute double inlineOverflowSize;
    readonly attribute double blockOverflowSize;

    attribute double inlineOffset;
    attribute double blockOffset;

    readonly attribute sequence&lt;Box> unpositionedBoxes;

    readonly attribute ChildBreakToken? breakToken;

    readonly attribute double dominantBaseline;
    readonly attribute double alphabeticBaseline;
    readonly attribute double centerBaseline;

    readonly attribute Object data;
};
</pre>

A {{Fragment}} represents a CSS <a>fragment</a> of a <a>box</a> after layout has occurred on that
box. This is produced by the {{Box/doLayout()}} method.

The {{Fragment}} has {{Fragment/inlineSize}} and {{Fragment/blockSize}} attributes, which are set by
the respective {{Box}}'s layout algorithm. They cannot be changed. If the <a>current layout</a>
requires a different {{Fragment/inlineSize}} or {{Fragment/blockSize}} the author must perform
{{doLayout()}} again with different arguments in order to get different results.

The {{Fragment}} has {{Fragment/inlineOverflowSize}} and {{Fragment/blockOverflowSize}} attributes.
This is the size of the overflow area of the fragment. If the fragment didn't overflow these
attributes will be the same as {{Fragment/inlineSize}} and {{Fragment/blockSize}} respectively.

The {{Fragment}} has a list of {{Fragment/unpositionedBoxes}}. These are boxes which the child
layout algorithm could not position itself, and should be positioned by either the <a>current
layout</a>, or a <a>parent layout</a>.

NOTE: As an example, if a <a>child layout</a> is not a <a>containing block</a> its resulting
    {{Fragment}} will contain a list of the positioned boxes (e.g. an element that has ''positioned:
    absolute'') it cannot layout. If the <a>current layout</a> is a <a>containing block</a> it
    should layout and position those boxes, or if not pass them up to it's <a>parent layout</a>.

The author inside the current layout can position a resulting {{Fragment}} by setting its
{{Fragment/inlineOffset}} and {{Fragment/blockOffset}} attributes. If not set by the author they
default to zero.

<div class="example">
The following code assumes that each child {{Box}} is a <a>containing block</a> and produces exactly
one {{Fragment}} for simplicity.

The layout algorithm performs a block-like layout (laying things out in the block direction), while
centering its children in the inline direction.

<pre class="lang-javascript">
registerLayout('block-like', class {
    *layout(space, children, styleMap, breakToken) {
        let blockOffset = 0;
        const inlineSize = resolveInlineSize(space, styleMap);
        const childFragments = [];

        // ... snip ...

        for (let child of children) {
            let fragment = yield child.doLayout(childSpace);

            // Position the fragment in a block like manner, centering it in the
            // inline direction.
            fragment.blockOffset = blockOffset;
            fragment.inlineOffset =
                Math.max(0, (inlineSize - fragment.inlineSize) / 2);

            blockOffset += fragment.blockSize;
        }

        // ... snip ...

        return {
            blockSize: blockOffset,
            inlineSize: inlineSize,
            fragments: childFragments,
        };
    }
});
</pre>
</div>

The {{Fragment}}'s {{Fragment/breakToken}} specifies where the {{Box}} last fragmented. If the
{{Fragment/breakToken}} is null the {{Box}} cannot produce any more {{Fragment}}s. The
{{Fragment/breakToken}} can be passed to the {{Box/doLayout()}} function to produce the next
{{Fragment}} for a particular {{Box}}. The {{Fragment/breakToken}} cannot be changed. If the
<a>current layout</a> requires a different {{Fragment/breakToken}} the author must perform
{{Box/doLayout()}} again with different arguments.

The {{Fragment}}'s {{Fragment/dominantBaseline}}, {{Fragment/alphabeticBaseline}}, and
{{Fragment/centerBaseline}} attributes specify where all the baselines for the {{Fragment}} are
positioned. They cannot be changed.

The {{Fragment}}'s {{Fragment/data}} attribute is used by the author to pass arbitary data between
the <a>child layout</a> and <a>current layout</a>. The data is <a>structured cloned</a>.

Constraint Spaces {#constraint-spaces}
--------------------------------------

<pre class='idl'>
[
    Constructor(optional ConstraintSpaceOptions options),
    Constructor(ConstraintSpace space, optional ConstraintSpaceOptions options)
]
interface ConstraintSpace {
    readonly attribute double? inlineSize;
    readonly attribute double? blockSize;

    readonly attribute boolean inlineSizeFixed;
    readonly attribute boolean blockSizeFixed;

    readonly attribute double inlinePercentResolutionSize;
    readonly attribute double blockPercentResolutionSize;

    readonly attribute boolean inlineScrollTrigger;
    readonly attribute boolean blockScrollTrigger;

    readonly attribute boolean blockFragmentation;
    readonly attribute BlockFragmentationType blockFragmentationType;
};

dictionary ConstraintSpaceOptions {
    double? inlineSize = null;
    double? blockSize = null;

    boolean inlineSizeFixed = false;
    boolean blockSizeFixed = false;

    double inlinePercentResolutionSize = null;
    double blockPercentResolutionSize = null;

    boolean inlineScrollTrigger = false;
    boolean blockScrollTrigger = false;

    double blockFragmentation = false;
    BlockFragmentationType blockFragmentationType = "none";
};

enum BlockFragmentationType { "none", "page", "column", "region" };
</pre>

A {{ConstraintSpace}} is passed into the <a>layout method</a> which represents the available space
for the <a>current layout</a> to perform layout inside. It is also used to pass information about
the available space into a <a>child layout</a>.

The {{ConstraintSpace}} has {{ConstraintSpace/inlineSize}} and {{ConstraintSpace/blockSize}}
attributes. This represent the maximum size of a {{Fragment}} which the <a>current layout</a> should
produce.

NOTE: Some layouts may need to produce a {{Fragment}} which exceed this size. For example a
    <a>replaced element</a>. The <a>parent layout</a> should expect this to occur and deal with it
    appropriately.

If either the {{ConstraintSpace/inlineSize}} or {{ConstraintSpace/blockSize}} attributes are null
the <a>current layout</a> can assume it has infinite space to perform layout in that direction.

NOTE: As an example a <a>current layout</a> could query for the <a>max content contribution</a> of a
    {{Box}} by giving it a {{ConstraintSpace}} which has a infinite {{ConstraintSpace/inlineSize}}
    and {{ConstraintSpace/blockSize}}.

A <a>parent layout</a> may require the <a>current layout</a> to be exactly a particular size. If
the {{ConstraintSpace/inlineSizeFixed}} or {{ConstraintSpace/blockSizeFixed}} are true the
<a>current layout</a> should produce a {{Fragment}} with a fixed size in the appropriate direction.

<div class="example">
The following code assumes that each child {{Box}} is a <a>containing block</a>, each child can be
"flexed", and produces exactly one {{Fragment}} for simplicity.

The layout algorithm performs a flexbox-like distribution of spare space in the inline direction. It
creates child constraint spaces which specify that a child should be a fixed inline size.

<pre class="lang-javascript">
registerLayout('flex-distribution-like', class {
    *layout(space, children, styleMap, breakToken) {
        const inlineSize = resolveInlineSize(space, styleMap);

        // Calculate the unconstrained size for each child.
        for (let child of children) {
            let fragment = yield child.doLayout(space);
            unconstrainedSizes.push(fragment.inlineSize);
            totalSize += fragment.inlineSize;
        }

        // Distribute space spare between children.
        const remainingSpace = Math.max(0, inlineSize - totalSize);
        const extraSpace = remainingSpace / children.length;
        const fragments = [];
        let inlineOffset = 0;
        for (let i = 0; i < children.length; i++) {
            let fragment = yield child.doLayout(new ConstraintSpace({
                inlineSize: unconstrainedSizes[i] + extraSpace,
                inlineSizeFixed: true,
                blockSize: space.blockSize
            }));

            fragment.inlineOffset = inlineOffset;
            inlineOffset += fragment.inlineSize;

            fragments.push(fragment);
        }

        return {
            fragments: fragments,
            inlineSize: inlineSize,
            /* etc. */
        };
    }
});
</pre>
</div>

The {{ConstraintSpace}} has {{ConstraintSpace/inlinePercentResolutionSize}} and
{{ConstraintSpace/blockPercentResolutionSize}} attributes. These represent the size that a layout
percentages should be resolved against while performing layout.

The {{ConstraintSpace}} has {{ConstraintSpace/inlineScrollTrigger}} and
{{ConstraintSpace/blockScrollTrigger}} attributes. The <a>current layout</a> can use this
information to early opt-out of a layout if it knows it will require additional space for a scroll
bar in that direction. If either the {{ConstraintSpace/inlineScrollTrigger}} or
{{ConstraintSpace/blockScrollTrigger}} attributes are null the <a>current layout</a> can
assume it does not need to report to the parent layout that it will require a scroll bar in that
direction.

The scroll trigger offset should only be present when the <a>parent layout</a> will need to reserve
additional space for the scroll bar. If an overlay scroll bar displayed by the user-agent, the
scroll trigger offset should not be present (as no additional space needs to be reserved for the
overlay scroll bar).

The author may ignore this information and produce a fragment with a
{{LayoutResult/inlineOverflowSize}} or {{LayoutResult/blockOverflowSize}} which exceeds the scroll
trigger offset. In this case the engine invoke the layout algorithm again with space reserved for
the scroll bar if required.

NOTE: The user-agent should provide tooling to the author if this case is triggered, advising that
    the author may be able to optimize their layout with an early opt-out.

<div class="example">
The following figures illustrate some different possible {{ConstraintSpace}}s which could be
provided to a <a>current layout</a>.
<table>
    <tbody>
        <tr>
            <td>
                <pre>
                    ConstraintSpace {
                        inlineSize = 120
                        blockSize = 120
                    }
                </pre>
            </td>
            <td>
                <pre>
                    ConstraintSpace {
                        inlineSize = 120
                        blockSize = 100
                        blockScrollTrigger = true
                    }
                </pre>
            </td>
        </tr>
        <tr>
            <td><img style="height: 50%; text-align: center;" src="images/constraint_space_1.png"></img></td>
            <td><img style="height: 50%; text-align: center;" src="images/constraint_space_2.png"></img></td>
        </tr>
        <tr>
            <td>
                <pre>
                    ConstraintSpace {
                        inlineSize = 140
                        blockSize = 100
                        inlineScrollTrigger = true
                        blockScrollTrigger = true
                    }
                </pre>
            </td>
            <td>
                <pre>
                    ConstraintSpace {
                        inlineSize = 140
                        blockSize = 100
                        blockFragmentation = true
                    }
                </pre>
            </td>
        </tr>
        <tr>
            <td><img style="height: 50%; text-align: center;" src="images/constraint_space_3.png"></img></td>
            <td><img style="height: 50%; text-align: center;" src="images/constraint_space_4.png"></img></td>
        </tr>
    </tbody>
</table>
</div>

<div class="example">
The following code assumes that each child {{Box}} is a <a>containing block</a>, and produces
exactly one {{Fragment}} for simplicity.

The layout algorithm performs a block-like with an early opt-out if it will trigger a scroll.

<pre class="lang-javascript">
registerLayout('block-like-with-scroll', class {
    *layout(space, children, styleMap, breakToken) {
        let blockOffset = 0;
        const inlineSize = resolveInlineSize(space, styleMap);
        const childFragments = [];

        // ... snip ...

        for (let child of children) {
            let fragment = yield child.doLayout(childSpace);

            fragment.blockOffset = blockOffset;
            blockOffset += fragment.blockSize;

            // Early opt-out of layout algorithm if we triggered a scroll in the
            // block direction.
            if (space.blockScrollTrigger && space.blockSize < blockOffset) {
                return {blockScrollTriggered: true};
            }
        }

        // ... snip ...

        return {
            blockSize: resolveBlockSize(space, styleMap, blockOffset),
            inlineSize: inlineSize,
            blockOverflowSize: blockOffset,
            fragments: childFragments,
        };
    }
});
</pre>
</div>

The {{ConstraintSpace}} has {{ConstraintSpace/blockFragmentation}} and
{{ConstraintSpace/blockFragmentationType}} attributes. The <a>current layout</a> should produce a
{{Fragment}} which fragments at the {{ConstraintSpace/blockSize}} if possible.

The <a>current layout</a> may choose not to fragment a child {{Box}} based on the
{{ConstraintSpace/blockFragmentationType}} if the child has a property like ''break-inside:
avoid-page;''.

<h4 id="constraint-space-exclusions">Constraint Space Exclusions</h4>

<pre class="idl">
partial interface ConstraintSpace {
    void addExclusion(Fragment fragment, optional ExclusionOptions options);
    void addExclusion(Exclusion exclusion, optional ExclusionOptions options);

    sequence&lt;Exclusion> getExclusions(optional ExclusionOptions options);
};

enum ExclusionTag { "fragment", "exclusion", "float-left", "float-right" };
enum ExclusionType { "none", "inline-flow", "inline-start", "inline-end", "inline-both" };
enum ExclusionBox { "none", "border", "margin" };

dictionary ExclusionOptions {
    ExclusionTag tag = "fragment";
    ExclusionType type = "none"; // default to "inline-flow" instead?
    ExclusionBox box = "none"; // TODO needed?
};

interface Exclusion {
    readonly attribute ExclusionTag tag;
    readonly attribute ExclusionType type;
};

[Constructor(
        optional double inlineOffset = 0,
        optional double blockOffset = 0,
        optional double inlineSize = 0,
        optional double blockSize = 0)]
interface RectExclusion : Exclusion {
    readonly attribute double inlineOffset;
    readonly attribute double blockOffset;

    readonly attribute double inlineSize;
    readonly attribute double blockSize;
};

[Constructor(
        optional double inlineOffset = 0,
        optional double blockOffset = 0,
        optional double radius = 0)]
interface CircleExclusion : Exclusion {
    readonly attribute double inlineOffset;
    readonly attribute double blockOffset;

    readonly attribute double radius;
};

[Constructor(
        optional double inlineOffset = 0,
        optional double blockOffset = 0,
        optional double inlineRadius = 0,
        optional double blockRadius = 0)]
interface EllipseExclusion : Exclusion {
    readonly attribute double inlineOffset;
    readonly attribute double blockOffset;

    readonly attribute double inlineRadius;
    readonly attribute double blockRadius;
};

// TODO add other types of Exclusions here, PolygonExclusion.
</pre>

An {{Exclusion}} represents an area in the {{ConstraintSpace}} in which a layout shouldn't place
some types of {{Fragment}}s. An {{Exclusion}} might be:

 - A <a>float area</a>.

 - An <a>exclusion area</a>.

 - A placed {{Fragment}} added to the {{ConstraintSpace}}'s list of exclusions.

Some layouts may ignore exclusions and produce a {{Fragment}} which intersects with one. However
children of that {{Fragment}} may avoid the exclusion. An example of this behaviour is block layout
which isn't a <a>formatting context</a> with inline children avoiding an intruding float.

<div class="example">
TODO add image of different types of exclusions.
</div>

<div class="example">
TODO add example of exclusion usage.
</div>

<h4 id="derived-constraint-spaces">Derived Constraint Spaces</h4>

<pre class="idl">
partial interface ConstraintSpace {
    // TODO add arguments to layoutOpportunities that make sense.
    ConstraintSpaceIterable layoutOpportunities();
};

// TODO should be a generator function instead?
interface ConstraintSpaceIterable {
    iterable&lt;DerivedConstraintSpace>;
};

interface DerivedConstraintSpace : ConstraintSpace {
    readonly attribute double inlineOffset;
    readonly attribute double blockOffset;
};
</pre>

A {{ConstraintSpace}} has a {{ConstraintSpace/layoutOpportunities()}} method which is used to create
a {{DerivedConstraintSpace}}.

A {{DerivedConstraintSpace}} is a copy of an area of the parent {{ConstraintSpace}}. It also has
{{DerivedConstraintSpace/inlineOffset}} and {{DerivedConstraintSpace/blockOffset}} attributes which
indicate its position within the parent {{ConstraintSpace}}.

The {{DerivedConstraintSpace}} should contain all relevant {{Exclusion}}s from its parent
{{ConstraintSpace}}.

The {{ConstraintSpace/inlineSize}} and {{ConstraintSpace/blockSize}} attributes of the
{{DerivedConstraintSpace}} may be different from the parent {{ConstraintSpace}}. However the
{{ConstraintSpace/inlinePercentResolutionSize}} and {{ConstraintSpace/blockPercentResolutionSize}}
should remain the same as the parent.

The {{DerivedConstraintSpace}} is used for "fitting" a child within a larger {{ConstraintSpace}}.

Issue: Add image showing a child "fitting" within a larger {{ConstraintSpace}}.

Issue: Add example code.

Breaking and Fragmentation {#breaking-and-fragmentation}
--------------------------------------------------------

<pre class="idl">
interface ChildBreakToken {
    readonly attribute BreakType breakType;
    readonly attribute Box box;
};

interface BreakToken {
    readonly attribute sequence&lt;ChildBreakToken> childBreakTokens;
    readonly attribute Object data;
};

dictionary BreakTokenOptions {
    sequence&lt;ChildBreakToken> childBreakTokens;
    Object data = null;
};

enum BreakType { "none", "inline", "inline-hyphen", "column", "page", "region" };
</pre>

Issue(w3c/css-houdini-drafts#258): What type of {{BreakType}}s are needed?

A {{Box}} can produce multiple {{Fragment}}s. A {{Box}} may fragment in the block direction if a
{{ConstraintSpace/blockFragmentation}} is true. It may fragment in the inline direction if it is an
inline layout.

A subsequent {{Fragment}} is produced by using the previous {{Fragment}}'s {{Fragment/breakToken}}.
This tells the <a>child layout</a> to produce a {{Fragment}} starting at the point encoded in the
{{ChildBreakToken}}.

When returning a list of {{Fragment}}s from the <a>current layout</a> the list of {{Fragment}}s must
have a contiguous set of {{Fragment/breakToken}}s.

<div class="example">
TODO add example {{ConstraintSpace}} with placed fragments, fragmenting over lines and
columns/pages.
</div>

<div class="example">
TODO add example showing non-contiguous set of fragments.
</div>

<div class="example">
This example shows how to use a previous {{Fragment}}'s {{Fragment/breakToken}} to produce the next
{{Fragment}} in the sequence.

<pre class="lang-javascript">
registerLayout('fragmenting', class {
    *layout(space, children, styleMap, breakToken) {

    // ... snip ...

    const fragments = [];
    let breakToken = null;
    for (let child of children) {
        // This do-while loop will keep producing fragments for a child box
        // until it cannot produce any more.
        do {
            // ... snip ... (setting up child constraint space).

            let fragment = yield child.doLayout(childSpace, breakToken);
            breakToken = fragment.breakToken;

            fragments.push(fragment);
        } while (breakToken);
    }

    // ... snip ...

    }
});
</pre>
</div>

<div class="example">
This example shows how to use resume a layout given a breakToken.

<pre class="lang-javascript">
registerLayout('fragmenting', class {
    *layout(space, children, styleMap, breakToken) {
        const fragments = [];

        // Produce the next fragment in the sequence if we have a breakToken.
        if (breakToken) {
            for (let childBreakToken of breakToken.childBreakTokens) {
                let fragment = yield childBreakToken.box.doLayout(
                        childSpace, childBreakToken);

                fragments.push(fragment);
            }
        }
    }
});
</pre>
</div>

Layout Invalidation {#layout-invalidation}
==========================================

<div class='issue'>
TODO, list all the ways that layout can be invalidated, namely:
    - Computed style change.
    - Child computed style change.
    - Child add/remove change.
    - etc.
</div>

Layout Engine {#layout-engine}
==============================

<pre class="idl">
interface FragmentRequestToken {
  // Has internal slots:
  // [[box]] - The box to generate the fragment for.
  // [[constraintSpace]] - The constraint space to perform layout in.
  // [[breakToken]] - The break token to resume the layout with.
};
</pre>

The layout method on the author supplied layout class is a generator function instead of a regular
javascript function. This is for user-agents to be able to support asyncronous and parallel layout
engines.

When an author invokes the {{Box/doLayout()}} method on a {{Box}} the user-agent doesn't
synchronously generate a {{Fragment}} to return to the author's code. Instead it returns a
{{FragmentRequestToken}}. This is a completely opaque object to the author but contains internal
slots which encapsulates the {{Box/doLayout()}} method call.

When a {{FragmentRequestToken}}(s) are yielded from a layout generator object the user-agent's
layout engine may run the algorithm asynchronously with other work, and/or on a different thread of
execution. When {{Fragment}}(s) have been produced by the engine, the user-agent will 'tick' the
generator object with the resulting {{Fragment}}(s).

Issue: Write algorithm "<dfn>generate a fragment</dfn>" which encapsulates this.

<div class="example">
An example layout engine written in javascript is shown below.

<pre class="lang-javascript">
class LayoutEngine {
  // This function takes the root of the Box-tree, a ConstraintSpace, and a
  //  BreakToken to (if paginating for printing for example) and generates a
  // Fragment.
  layoutEntry(rootBox, rootPageConstraintSpace, breakToken) {
    return layoutFragment({
      box: rootBox,
      constraintSpace: rootPageConstraintSpace,
      breakToken: breakToken,
    });
  }

  // This function takes a FragmentRequestToken and calls the appropriate layout
  // algorithm to generate the a Fragment.
  layoutFragment(fragmentRequest) {
    const box = fragmentRequest.box;
    const algorithm = selectLayoutAlgorithmForBox(box);
    const fragmentRequestGenerator = algorithm.layout(
        fragmentRequest.constraintSpace,
        box.children,
        box.styleMap,
        fragmentRequest.breakToken);

    let nextFragmentRequest = fragmentRequestGenerator.next();

    while (!nextFragmentRequest.done) {
      // A user-agent may decide to perform layout to generate the fragments in
      // parallel on separate threads. This example performs them synchronously
      // in order.
      let fragments = nextFragmentRequest.value.map(layoutFragment);

      // A user-agent may decide to yield for other work (garbage collection for
      // example) before resuming this layout work. This example just performs
      // layout synchronously without any ability to yield.
      nextFragmentRequest = fragmentRequestGenerator.next(fragments);
    }

    return nextFragmentRequest.value; // Return the final Fragment.
  }
}
</pre>
</div>

TODO explain parallel layout + {{FragmentRequestToken}}, etc.

Registering A Layout {#registering-a-layout}
============================================

<pre class='idl'>
callback VoidFunction = void ();

partial interface LayoutWorkletGlobalScope {
    void registerLayout(DOMString name, VoidFunction layoutCtor);
};
</pre>

The {{LayoutWorkletGlobalScope}} has a map of <b>name to layout constructor map</b>. Initially this
map is empty; it is populated when {{registerLayout(name, layoutCtor)}} is called.

Issue: Write full register algorithm, and checks required.

<div class='note'>
    This is what the shape of the class should be:
    <pre class='idl'>
        callback interface LayoutClass {
            readonly attribute sequence&lt;DOMString> inputProperties;
            readonly attribute sequence&lt;DOMString> childInputProperties;

            LayoutResult layout(
                    ConstraintSpace space,
                    sequence&lt;Box> children,
                    StylePropertyMap styleMap,
                    BreakToken break);
            void childrenChange(/*
                    added children,
                    removed children,
                    idx updated children,
                    similar to Array.observe */);
        };
    </pre>
</div>

Layout Notation {#layout-notation}
==================================

<pre class='prod'>
    <dfn>layout()</dfn> = layout( <<ident>> )
    <dfn>inline-layout()</dfn> = inline-layout( <<ident>> )
</pre>

The <<layout()>> and <<inline-layout()>> function is an additional notation to be supported by the ''display'' property.

Issue: Resolve this with css-display-3 once required.

Layout {#layout}
================

Performing layout {#performing-layout}
--------------------------------------

<pre class='idl'>
dictionary LayoutResult {
    double minContent;
    double maxContent;
    double width;
    double height;
    sequence&lt;Fragment> fragments;
    sequence&lt;Fragment> unpositionedFragments;
    BreakToken breakToken;
    double baseline;
};
</pre>

{{LayoutClass/layout()}} is invoked by the user agent when <a>generate a layout</a> for a <a>box</a>.

The user agent passes in:
  - The current children for the <a>box</a>, with only {{LayoutClass/childInputProperties}} on
    {{Box/styleMap}}
  - The available space defined by a {{ConstraintSpace}}
  - The computed style of the <a>box</a>, with only {{LayoutClass/inputProperties}}
  - The {{BreakToken}} if any, for where the <a>box</a> was last fragmented.

The author defined code should produce a {{LayoutResult}}.

The {{LayoutResult}} consists of:
 - A {{LayoutResult/minContent}} which represents the fragment's <a>min-content inline-size
    contribution</a>.
 - A {{LayoutResult/maxContent}} which represents the fragment's <a>max-content inline-size
    contribution</a>.
 - A {{LayoutResult/width}} which represents the fragment's resulting width.
 - A {{LayoutResult/height}} which represents the fragment's resulting height.
 - A list of {{LayoutResult/fragments}} which represents the fragment's direct child fragments.
 - A list of {{LayoutResult/unpositionedFragments}} which represents the fragment's children which
    should be positioned by a parent fragment.
 - A {{LayoutResult/breakToken}} which represents where the current layout's box last broke.
 - A {{LayoutResult/baseline}} which represents the baseline of the fragment.

Issue: Write the following into the algorithm.

If any {{Fragment}}s appear in both the list of {{LayoutResult/fragments}} or the list of
{{LayoutResult/unpositionedFragments}} the user agent should throw an error.

The user agent should check that a consistent set of {{Fragment}}s generated from a {{Box}} is
returned in either the list of {{LayoutResult/fragments}} or {{LayoutResult/unpositionedFragments}}.
(Consistent being that a {{Fragment/breakToken}} from one {{Fragment}} was used to generate another
{{Fragment}} in the set).

If any {{Fragment}}s appear more than once, the user agent should throw an error.

When the user agent wants to <dfn>generate a layout</dfn> of a <<layout()>> or <<inline-layout()>>
for a box it <em>must</em> run the following steps:

Issue: TODO specify these steps.

Examples {#examples}
====================

Example 1: A simple block layout {#example-1}
---------------------------------------------

<pre class='lang-javascript'>
// Inside LayoutWorkletGlobalScope

// Note this is meant to be similar (*not* the same) as a block layout.
// Everything is done in 'width' & 'height' for easy reading.
registerLayout('simple-flow', class {
    static get inputProperties() { return ['width', 'height'] }
    static get childrenInputProperties() { return ['x', 'y', 'position'] }

    layout(children, constraintSpace, styleMap, breakToken) {
        const absoluteChildren = [];
        const fixedChildren = [];
        const fragments = [];

        // Resolve our width using the available width in 'constraintSpace', and
        // our computed width property.
        let width = resolveWidth(constraintSpace, styleMap.get('width'));

        // Create a new constraint space for our children to consume.
        let childConstraintSpace = new ConstraintSpace(constraintSpace);
        childConstraintSpace.width = width;

        // Track the used height, min and max content.
        let height = 0;
        let minContent = 0;
        let maxContent = 0;

        for (let child of children) {
            // Check if the child is out of flow positioned.
            const childPosition = child.styleMap.get('position');

            if (childPosition == 'absolute') {
                absoluteChildren.push(child);
                continue;
            }

            if (childPosition == 'fixed') {
                fixedChildren.push(child);
                continue;
            }

            // Layout the in flow child.
            const childFragment = child.doLayout(childConstraintSpace);

            // Position the child.
            childFragment.x = 0;
            childFragment.y = height;

            // Update our current height, min and max content.
            height += childFragment.height;
            minContent = Math.max(childFragment.minContent, minContent);
            maxContent = Math.max(childFragment.maxContent, maxContent);
        }

        // Resolve the height.
        height = resolveHeight(constraintSpace, styleMap.get('height'), height);

        return {
            minContent: minContent,
            maxContent: maxContent,
            width: width,
            height: height,
            fragments: fragments,
            unPositionedChildren: absoluteChildren.concat(fixedChildren),
            breakToken: null
        };
    }
});
</pre>

<pre class='lang-markup'>
&lt;div id="myElement"&gt;
    &lt;div&gt;
        CSS is awesome.
    &lt;/div&gt;
&lt;/div&gt;

&lt;style&gt;
#myElement {
    display: layout('simple-flow');
}
&lt;/style&gt;
</pre>

Example 2: A simple line layout {#example-2}
--------------------------------------------

<pre class='lang-javascript'>
// Inside LayoutWorkletGlobalScope

// Note this is meant to be similar (*not* the same) as a inline layout.
// Everything is done in 'width' & 'height' for easy reading.
registerLayout('simple-inline-flow', class {
    static get inputProperties() { return ['width', 'height'] }
    static get childrenInputProperties() { return [] }

    layout(children, constraintSpace, styleMap, breakToken) {
        // Resolve our width using the available width in 'constraintSpace', and
        // our computed width property.
        const width = resolveWidth(constraintSpace, styleMap.get('width'));
        const fragments = [];
        let height = 0;

        // TODO compute these.
        let minContent = 0;
        let maxContent = 0;

        let childFragment = null;
        let lineFragments = [];
        let lineHeight = 0;
        let remainingLineWidth = width; // NOTE: should be helper on constraint space?

        const childIter = chidlren.values();
        let child = childIter.next().value;
        let breakToken = null;

        while (child) {
            // Create a new constraint space for the child, with all the current
            // positioned children.
            const childConstraintSpace = new ConstraintSpace(constraintSpace);
            childConstraintSpace.addExclusion(new ExclusionRect(width, height, 0, 0));
            childConstraintSpace.addExclusions(lineFragments);

            // Perform layout on the child.
            childFragment = child.doLayout(childConstraintSpace, breakToken);
            fragments.push(childFragment);

            // Check if we need to position the fragment on the next line.
            if (childFragment.width > remainingLineWidth) {
                // Need to start a new line.
                lineFragments = [];
                height += lineHeight;
                lineHeight = 0;
                remainingLineWidth = width;
            }

            // Position the fragment horizontally.
            childFragment.x = width - remainingLineWidth;

            lineFragments.push(childFragment);
            lineHeight = Math.max(lineHeight, childFragment.height);
            remainingLineWidth -= childFragment.width;

            // Update the line fragments positions, based on the new lineHeight.
            for (let frag of lineFragments) {
                frag.y = lineHeight - frag.height;
            }

            // Step to the next child if required.
            if (childFragment.breakToken) {
                breakToken = childFragment.breakToken;
            } else {
                child = childIter.next().value;
                breakToken = null;
            }
        }

        // Resolve the height.
        height = resolveHeight(constraintSpace, styleMap.get('height'), height);

        return {
            minContent: minContent,
            maxContent: maxContent,
            width: width,
            height: height,
            fragments: fragments,
            unpositionedFragments: [],
            breakToken: null
        };
    }
});
</pre>
